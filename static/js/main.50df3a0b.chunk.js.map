{"version":3,"sources":["components/Webcam.tsx","components/Timer.tsx","faceAPI.ts","views/WebcamPage.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Webcam","props","useState","webcamStream","setWebcamStream","videoInputs","setVideoInputs","activeDeviceId","setActiveDeviceId","mirrored","setMirrored","currentFrame","setCurrentFrame","currentFaceArea","setCurrentFaceArea","resultSpoofing","setResultSpoofing","resultFaceScore","setResultFaceScore","successCount","setSuccessCount","mirroredRef","useRef","selectRef","videoRef","canvasRef","hiddenCanvasRef","canvasContainerRef","updateWebcamStream","a","getTracks","forEach","track","stop","navigator","mediaDevices","getUserMedia","video","deviceId","exact","undefined","audio","getVideoInputs","enumerateDevices","allDevives","filter","x","kind","useEffect","current","srcObject","play","callback","canvas","context","getContext","scaleRatio","offsetWidth","videoWidth","encodeFrame","hiddenCanvas","hcontext","h","videoHeight","width","height","drawImage","toDataURL","checked","scale","renderFrame","ratio2","strokeStyle","color","lineWidth","rect","left","top","right","bottom","stroke","drawFaceArea","submit","submitImage","faceID","result","isSuccessful","spoofing","face_score","bbox","prev","timeout","setTimeout","clearTimeout","autoPlay","className","ref","muted","onChange","e","target","value","map","label","type","children","Timer","seconds","timeLeft","setTimeLeft","Math","floor","toString","padStart","imageURL","id","imageEncoded","split","fetch","method","headers","body","JSON","stringify","image","then","res","json","catch","err","WebcamPage","location","useLocation","seed","URLSearchParams","search","get","expired","setExpired","passed","setPassed","atob","App","path","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.50df3a0b.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\n\ninterface WebcamProps {\n    children: JSX.Element,\n    faceID: string,\n    submitImage?: (img: string, id: string) => any,\n    callback?: () => void\n};\n\ninterface FaceArea {\n    color: string,\n    left: number,\n    top: number,\n    right: number,\n    bottom: number\n};\n\nexport const Webcam = (props: WebcamProps) => {\n    const [webcamStream, setWebcamStream] = useState<MediaStream | null>(null);\n    const [videoInputs, setVideoInputs] = useState<Array<MediaDeviceInfo> | null>(null);\n    const [activeDeviceId, setActiveDeviceId] = useState<string | null>(null);\n    const [mirrored, setMirrored] = useState<boolean>(false);\n    const [currentFrame, setCurrentFrame] = useState<number>(0);\n    const [currentFaceArea, setCurrentFaceArea] = useState<FaceArea | null>(null);\n    const [resultSpoofing, setResultSpoofing] = useState<number | null>(null);\n    const [resultFaceScore, setResultFaceScore] = useState<number | null>(null);\n    const [successCount, setSuccessCount] = useState<number>(0);\n    const mirroredRef = useRef<HTMLInputElement>(null);\n    const selectRef = useRef<HTMLSelectElement>(null);\n    const videoRef = useRef<HTMLVideoElement>(null);\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const hiddenCanvasRef = useRef<HTMLCanvasElement>(null);\n    const canvasContainerRef = useRef<HTMLDivElement>(null);\n\n    const updateWebcamStream = async () => {\n        if (webcamStream) // stop the current stream\n            webcamStream.getTracks().forEach(track => track.stop());\n        \n        setWebcamStream(\n            await navigator\n                .mediaDevices\n                .getUserMedia({\n                    video: { deviceId: { exact: activeDeviceId ?? undefined } },\n                    audio: false\n                })\n        );\n    };\n\n    const getVideoInputs = async () => {\n        if (!videoInputs) {\n            const allDevives = \n                await navigator\n                    .mediaDevices\n                    .enumerateDevices();\n            \n            setVideoInputs(allDevives.filter(x => x.kind === 'videoinput'));\n        }\n    };\n\n    useEffect(() => { // get the webcam stream\n        getVideoInputs();\n    }, []);\n\n    useEffect(() => {\n        updateWebcamStream();\n    }, [activeDeviceId]);\n\n    useEffect(() => { // play the webcam stream in the hidden video tag\n        videoRef.current!.srcObject = webcamStream;\n        videoRef.current?.play();\n    }, [webcamStream]);\n\n    useEffect(() => {\n        if (successCount >= 5 && props.callback)\n            props.callback();\n    }, [successCount]);\n\n    useEffect(() => {\n        const video = videoRef.current!;\n        const canvas = canvasRef.current!;\n        const context = canvas.getContext('2d')!;\n        const container = canvasContainerRef.current!;\n        const scaleRatio = container.offsetWidth / video.videoWidth;\n        \n        const renderFrame = () => { // render the current webcam stream frame in the canvas \n            canvas.width = video.videoWidth * scaleRatio;\n            canvas.height = video.videoHeight * scaleRatio;\n\n            if (mirroredRef.current?.checked)\n                context.scale(-1, 1);\n\n            context.drawImage(video, mirroredRef.current?.checked ? -1 * canvas.width : 0, 0, canvas.width, canvas.height);\n        };\n\n        const drawFaceArea = () => {\n            if (currentFaceArea) {\n                const ratio2 = canvas.width / 600;\n                context.strokeStyle = currentFaceArea.color;\n                context.lineWidth = 2;\n                context.rect(\n                    currentFaceArea.left * ratio2 - (mirroredRef.current?.checked ? canvas.width : 0), \n                    currentFaceArea.top * ratio2, \n                    (currentFaceArea.right - currentFaceArea.left) * ratio2, \n                    (currentFaceArea.bottom - currentFaceArea.top) * ratio2\n                );\n                context.stroke();\n            }\n        };\n\n        const encodeFrame = () => {\n            // resize and convert the frame to jpeg, then send it \n            const hiddenCanvas = hiddenCanvasRef.current!;\n            const hcontext = hiddenCanvas.getContext('2d')!;\n            const \n                ratio = video.videoHeight / video.videoWidth,\n                w = 600,\n                h = ratio * w;\n            hiddenCanvas.width = w;\n            hiddenCanvas.height = h;\n\n            hcontext.drawImage(video, 0, 0, w, h);\n            // if (mirroredRef.current?.checked)\n            //     hcontext.scale(-1, 1);\n            // hcontext.drawImage(video, mirroredRef.current?.checked ? -1 * hiddenCanvas.width : 0, 0, w, h);\n\n            const res = hiddenCanvas.toDataURL('image/jpeg', 1.0);\n            return res;\n        };\n\n        renderFrame();\n        drawFaceArea();\n        const submit = async () => {\n            const result = await props.submitImage!(encodeFrame(), props.faceID);\n            const isSuccessful = result.spoofing < 0.3 && result.face_score < 0.7;\n            setCurrentFaceArea({\n                ...result.bbox,\n                color: isSuccessful ? 'green' : 'blue'\n            });\n            setResultFaceScore(result.face_score);\n            setResultSpoofing(result.spoofing);\n            if (isSuccessful)\n                setSuccessCount(prev => prev + 1);\n        };\n\n        if (props.submitImage && currentFrame % 15 === 0)\n            submit();\n        \n        const timeout = setTimeout(\n            () => setCurrentFrame((prev) => prev + 1)\n        , 100); // re-render in 100ms\n        return () => clearTimeout(timeout);\n\n    }, [currentFrame]);\n\n    return (\n        <div>\n            <video autoPlay={true} className=\"hidden\" ref={videoRef} muted />\n            <div className=\"grid grid-cols-2\">\n                <div ref={canvasContainerRef} className=\"col-span-2 lg:col-span-1\">\n                    <canvas ref={canvasRef} />\n                </div>\n                <div className=\"col-span-2 lg:col-span-1 w-50 p-6 bg-gray-100\">\n                    <ul>\n                        <li>\n                            <b>Successful attemps:</b> {successCount}\n                        </li>\n                        <li>\n                            {!resultFaceScore || resultFaceScore > 0.7 ? <b> Not target face </b> : <b> Target face </b>}\n                        </li>\n                        <li>\n                            <b>spoofing:</b> {resultSpoofing}\n                        </li>\n                        <li>\n                            <label>\n                                <b>Select input:</b>\n                                <br />\n                                <select ref={selectRef} onChange={(e) => setActiveDeviceId(e.target.value)}>\n                                    { videoInputs?.map(x => <option value={x.deviceId}> {x.label || `Camera ${x.deviceId}`} </option>)} \n                                </select>\n                            </label>\n                        </li>\n                        <li>\n                            <label className=\"flex items-center\">\n                                <b className=\"pr-2 flex-col\">Mirror image:</b>\n                                <input className=\"flex-col\" type='checkbox' ref={mirroredRef} checked={mirrored} onChange={\n                                    (e) => {\n                                        setMirrored(e.target.checked);\n                                    }\n                                } />\n                            </label> \n                        </li>\n                        <li>\n                            {props.children}\n                        </li>\n                    </ul>\n                </div>\n            </div>\n            \n            <canvas ref={hiddenCanvasRef} className=\"hidden\" />\n        </div>\n    );\n}","import { useState, useEffect } from 'react' \n\ninterface TimerProps {\n    callback?: () => void,\n    seconds?: number\n}\n\nexport const Timer = (props: TimerProps) => {\n    const [timeLeft, setTimeLeft] = useState(props.seconds ?? 120);\n\n    useEffect(() => {\n        if (timeLeft <= 0) {\n            if (props.callback)\n                props.callback();\n            return;\n        }\n\n        const timeout = setTimeout(\n            () => setTimeLeft((prev) => prev - 1)\n        , 1000);\n        \n        return () => clearTimeout(timeout); \n    }, [timeLeft]);\n\n    return (\n        <div>\n            <span> {Math.floor(timeLeft / 60).toString().padStart(2, \"0\")} </span>\n            :\n            <span> {Math.floor(timeLeft % 60).toString().padStart(2, \"0\")} </span>\n        </div>\n    );\n}","const API_URL = 'https://toloka.suricatvision.com:8443/predictions/biometric'\n\nexport const submitImage = async (imageURL: string, id: string) => {\n    const imageEncoded = imageURL.split(',')[1];\n    return fetch(API_URL, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(JSON.stringify({\n            image: imageEncoded,\n            id: id\n        }))\n    })\n        .then(res => res.json())\n        .catch((err) => {\n            // console.log(err);\n            return null;\n        });\n}\n","import React, { useState, useEffect } from 'react';\nimport { useLocation, useParams } from 'react-router-dom';\nimport { Webcam, Timer } from '../components'\nimport { submitImage } from '../faceAPI'\n\nexport function WebcamPage() {\n    const location = useLocation();\n    const seed = new URLSearchParams(location.search).get('key');\n    // const { faceID } = useParams<{ faceID: string }>();\n    const faceID = new URLSearchParams(location.search).get('faceid');\n    const [ expired, setExpired ] = useState(false);\n    const [ passed, setPassed ] = useState(false);\n\n    if (!faceID || !seed)\n        return <div></div>;\n    \n    if (expired)\n        return <div>Time limit was reached.</div>;\n\n    if (passed)\n        return <div>5 successful attempts were reached, here's your key: {atob(seed + '|>*<|' + 'aaaaa')} </div>;\n\n    return (\n        <div> \n            <Webcam callback={() => setPassed(true)} faceID={faceID} submitImage={submitImage}>\n                <div>\n                    <b>Time left:</b> \n                    <br />\n                    <Timer seconds={120} callback={() => setExpired(true)} />\n                </div>\n            </Webcam>\n        </div>\n    );\n}","import React from 'react';\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom'\nimport { WebcamPage } from './views';\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route path='/'> <WebcamPage /> </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}