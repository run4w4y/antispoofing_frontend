{"version":3,"sources":["components/Webcam.tsx","components/Timer.tsx","faceAPI.ts","views/WebcamPage.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Webcam","props","useState","webcamStream","setWebcamStream","videoInputs","setVideoInputs","activeDeviceId","setActiveDeviceId","mirrored","setMirrored","currentFrame","setCurrentFrame","currentFaceArea","setCurrentFaceArea","resultSpoofing","setResultSpoofing","resultFaceScore","setResultFaceScore","successCount","setSuccessCount","dropTimeout","setDropTimeout","mediaRecorder","setMediaRecorder","setRecordedBlobs","blobsUploaded","setBlobsUploaded","startTs","setStartTs","mirroredRef","useRef","selectRef","videoRef","canvasRef","hiddenCanvasRef","canvasContainerRef","useTranslation","t","updateWebcamStream","i18n","a","getTracks","forEach","track","stop","navigator","mediaDevices","getUserMedia","video","deviceId","exact","undefined","audio","getVideoInputs","enumerateDevices","allDevives","filter","x","kind","resetDropTimeout","clearTimeout","console","log","window","setTimeout","expiredCallback","useEffect","current","srcObject","play","MediaRecorder","mimeType","Date","now","passed","callback","addEventListener","e","prev","data","start","uploadCallback","canvas","context","getContext","scaleRatio","offsetWidth","videoWidth","encodeFrame","hiddenCanvas","hcontext","h","videoHeight","width","height","drawImage","toDataURL","checked","scale","renderFrame","ratio2","strokeStyle","color","lineWidth","rect","left","top","right","bottom","stroke","drawFaceArea","submit","submitImage","imageURL","id","faceID","assignmentId","cameraSelected","find","cameraList","passedTime","result","face_score","isSuccessful","success","bbox","spoofing","timeout","autoPlay","className","ref","muted","playsInline","success_count","disabled","onChange","target","value","map","label","type","children","onClick","Timer","seconds","timeLeft","setTimeLeft","Math","floor","toString","padStart","params","imageEncoded","split","fetch","method","headers","body","JSON","stringify","image","camera_name","camera_list","then","res","json","catch","err","WebcamPage","location","useLocation","seed","URLSearchParams","search","get","language","expired","setExpired","expiredT","setExpiredT","setPassed","uploaded","setUploaded","changeLanguage","btoa","atob","key","clipboard","writeText","App","path","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","i18next","init","interpolation","escapeValue","lng","resources","en","common","common_en","ru","common_ru","ReactDOM","render","StrictMode","I18nextProvider","document","getElementById"],"mappings":"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","file":"static/js/main.8dc24fdc.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport config from '../config';\n\ninterface WebcamProps {\n    children: JSX.Element,\n    faceID: string,\n    assignmentId: string,\n    submitImage?: (params: any) => any,\n    callback?: () => void,\n    expiredCallback?: () => void,\n    uploadCallback?: () => void,\n    passed?: boolean,\n};\n\ninterface FaceArea {\n    color: string,\n    left: number,\n    top: number,\n    right: number,\n    bottom: number\n};\n\nexport const Webcam = (props: WebcamProps) => {\n    const [webcamStream, setWebcamStream] = useState<MediaStream | null>(null);\n    const [videoInputs, setVideoInputs] = useState<Array<MediaDeviceInfo> | null>(null);\n    const [activeDeviceId, setActiveDeviceId] = useState<string | null>(null);\n    const [mirrored, setMirrored] = useState<boolean>(true);\n    const [currentFrame, setCurrentFrame] = useState<number>(0);\n    const [currentFaceArea, setCurrentFaceArea] = useState<FaceArea | null>(null);\n    const [resultSpoofing, setResultSpoofing] = useState<number | null>(null);\n    const [resultFaceScore, setResultFaceScore] = useState<number | null>(null);\n    const [successCount, setSuccessCount] = useState<number>(0);\n    const [dropTimeout, setDropTimeout] = useState<number | null>(null);\n    const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);\n    const [recordedBlobs, setRecordedBlobs] = useState<Blob[]>([]);\n    const [blobsUploading, setBlobsUploading] = useState(false);\n    const [blobsUploaded, setBlobsUploaded] = useState(false);\n    const [blobsUploadError, setBlobsUploadError] = useState(\"\");\n    const [startTs, setStartTs] = useState<number | null>(null);\n    const mirroredRef = useRef<HTMLInputElement>(null);\n    const selectRef = useRef<HTMLSelectElement>(null);\n    const videoRef = useRef<HTMLVideoElement>(null);\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const hiddenCanvasRef = useRef<HTMLCanvasElement>(null);\n    const canvasContainerRef = useRef<HTMLDivElement>(null);\n    const {t, i18n} = useTranslation('common');\n\n    const updateWebcamStream = async () => {\n        if (webcamStream) // stop the current stream\n            webcamStream.getTracks().forEach(track => track.stop());\n        \n        setWebcamStream(\n            await navigator\n                .mediaDevices\n                .getUserMedia({\n                    video: { deviceId: { exact: activeDeviceId ?? undefined } },\n                    audio: false\n                })\n        );\n    };\n\n    const getVideoInputs = async () => {\n        if (!videoInputs) {\n            const allDevives = \n                await navigator\n                    .mediaDevices\n                    .enumerateDevices();\n            \n            setVideoInputs(allDevives.filter(x => x.kind === 'videoinput'));\n        }\n    };\n\n    const resetDropTimeout = () => {\n        if (dropTimeout)\n            clearTimeout(dropTimeout);\n\n        console.log('drop timeout cleared');\n\n        setDropTimeout(window.setTimeout(() => {\n            if (props.expiredCallback)\n                props.expiredCallback();\n        }, 60000));\n\n        console.log('drop timeout set');\n    }\n\n    const downloadVideo = () => {\n        setBlobsUploaded(true);\n        props.callback && props.callback();\n        \n        // const blob = new Blob(recordedBlobs, { type: 'video/webm' });\n\n        // setBlobsUploading(true);\n        // const url = `${config.s3url}/${props.assignmentId}.webm`;\n        // console.log(url);\n        // fetch(url, {\n        //     method: 'PUT',\n        //     body: blob,\n        //     headers: {\n        //         'Content-Type': 'video/webm'\n        //     }\n        // })\n        //     .then(resp => {\n        //         setBlobsUploaded(true);\n        //         console.log('uploaded');\n        //         props.callback && props.callback();\n        //     })\n        //     .catch(err => {\n        //         setBlobsUploadError(err);\n        //         console.log('not uploaded');\n        //     });\n    };\n\n    useEffect(() => { // get the webcam stream\n        getVideoInputs();\n        resetDropTimeout();\n    }, []);\n\n    useEffect(() => {\n        updateWebcamStream();\n    }, [activeDeviceId]);\n\n    useEffect(() => { // play the webcam stream in the hidden video tag\n        videoRef.current!.srcObject = webcamStream;\n        videoRef.current?.play();\n        if (webcamStream) {\n            setMediaRecorder(new MediaRecorder(webcamStream, { mimeType: 'video/webm' }));\n            setStartTs(Date.now());\n        }\n    }, [webcamStream]);\n\n    useEffect(() => {\n        if (successCount >= 5 || props.passed)\n            downloadVideo();\n    }, [successCount, props.passed]);\n\n    useEffect(() => {\n        mediaRecorder?.addEventListener('dataavailable', (e) => {\n            setRecordedBlobs(prev => [ ...prev, e.data ]);\n            console.log(e.data);\n        });\n\n        mediaRecorder?.start(1000);\n    }, [mediaRecorder]);\n\n    useEffect(() => {\n        if (blobsUploaded && props.uploadCallback)\n            props.uploadCallback()\n    }, [blobsUploaded]);\n\n    useEffect(() => {\n        const video = videoRef.current!;\n        const canvas = canvasRef.current!;\n        const context = canvas.getContext('2d')!;\n        const container = canvasContainerRef.current!;\n        const scaleRatio = container.offsetWidth / video.videoWidth;\n        \n        const renderFrame = () => { // render the current webcam stream frame in the canvas \n            canvas.width = video.videoWidth * scaleRatio;\n            canvas.height = video.videoHeight * scaleRatio;\n\n            if (mirroredRef.current?.checked)\n                context.scale(-1, 1);\n\n            context.drawImage(video, mirroredRef.current?.checked ? -1 * canvas.width : 0, 0, canvas.width, canvas.height);\n        };\n\n        const drawFaceArea = () => {\n            if (currentFaceArea) {\n                const ratio2 = canvas.width / 600;\n                context.strokeStyle = currentFaceArea.color;\n                context.lineWidth = 2;\n                context.rect(\n                    currentFaceArea.left * ratio2 - (mirroredRef.current?.checked ? canvas.width : 0), \n                    currentFaceArea.top * ratio2, \n                    (currentFaceArea.right - currentFaceArea.left) * ratio2, \n                    (currentFaceArea.bottom - currentFaceArea.top) * ratio2\n                );\n                context.stroke();\n            }\n        };\n\n        const encodeFrame = () => {\n            // resize and convert the frame to jpeg, then send it \n            const hiddenCanvas = hiddenCanvasRef.current!;\n            const hcontext = hiddenCanvas.getContext('2d')!;\n            const \n                ratio = video.videoHeight / video.videoWidth,\n                w = 600,\n                h = ratio * w;\n            hiddenCanvas.width = w;\n            hiddenCanvas.height = h;\n\n            hcontext.drawImage(video, 0, 0, w, h);\n            // if (mirroredRef.current?.checked)\n            //     hcontext.scale(-1, 1);\n            // hcontext.drawImage(video, mirroredRef.current?.checked ? -1 * hiddenCanvas.width : 0, 0, w, h);\n\n            const res = hiddenCanvas.toDataURL('image/jpeg', 1.0);\n            return res;\n        };\n\n        renderFrame();\n        drawFaceArea();\n        const submit = async () => {\n            const result = await props.submitImage!({\n                imageURL: encodeFrame(), \n                id: props.faceID, \n                assignmentId: props.assignmentId,\n                cameraSelected: videoInputs?.find(x => x.deviceId == activeDeviceId),\n                cameraList: videoInputs,\n                passedTime: startTs ? (Date.now() - startTs) / 1000 : null,\n            });\n            if (props.expiredCallback && result.stop && result.stop === true)\n                props.expiredCallback();\n            if (result.face_score < 0.7) \n                resetDropTimeout();\n            const isSuccessful = result.success;\n            setCurrentFaceArea({\n                ...result.bbox,\n                color: isSuccessful ? 'green' : 'blue'\n            });\n            setResultFaceScore(result.face_score);\n            setResultSpoofing(result.spoofing);\n            if (isSuccessful)\n                setSuccessCount(prev => prev + 1);\n        };\n\n        if (props.submitImage && currentFrame % 15 === 0)\n            submit();\n        \n        const timeout = setTimeout(\n            () => setCurrentFrame((prev) => prev + 1)\n        , 100); // re-render in 100ms\n        return () => clearTimeout(timeout);\n\n    }, [currentFrame]);\n\n    return (\n        <div>\n            <video autoPlay={true} className=\"hidden\" ref={videoRef} muted playsInline />\n            <div className=\"grid grid-cols-2\">\n                <div ref={canvasContainerRef} className=\"col-span-2 lg:col-span-1\">\n                    <canvas ref={canvasRef} />\n                </div>\n                <div className=\"col-span-2 lg:col-span-1 w-50 p-6 bg-gray-100\">\n                    <ul>\n                        <li>\n                            <b>{t('webcam.bar.success_count.title')}</b> \n                            {t('webcam.bar.success_count.text', {success_count: successCount})}\n                        </li>\n                        <li>\n                            {!resultFaceScore || resultFaceScore > 0.7 ? \n                            <b> {t('webcam.bar.face_score.not_target_face_text')} </b> : \n                            <b> {t('webcam.bar.face_score.target_face_text')} </b>}\n                        </li>\n                        <li>\n                            <b>spoofing:</b> {resultSpoofing}\n                        </li>\n                        <li>\n                            <label>\n                                <b>{t('webcam.bar.input_select.title')}</b>\n                                <br />\n                                <select ref={selectRef} disabled={true} onChange={(e) => setActiveDeviceId(e.target.value)}>\n                                    { videoInputs?.map(x => <option value={x.deviceId}> {x.label || `Camera ${x.deviceId}`} </option>)} \n                                </select>\n                            </label>\n                        </li>\n                        <li>\n                            <label className=\"flex items-center\">\n                                <b className=\"pr-2 flex-col\">{t('webcam.bar.mirror_toggle.title')}</b>\n                                <input className=\"flex-col\" type='checkbox' ref={mirroredRef} checked={mirrored} onChange={\n                                    (e) => {\n                                        setMirrored(e.target.checked);\n                                    }\n                                } />\n                            </label> \n                        </li>\n                        <li>\n                            {props.children}\n                        </li>\n                        <li>\n                            <button id=\"successButton\" className=\"hidden\" onClick={() => setSuccessCount(prev => prev + 1)}> Success button </button>\n                        </li> \n                    </ul>\n                </div>\n            </div>\n            \n            <canvas ref={hiddenCanvasRef} className=\"hidden\" />\n        </div>\n    );\n}","import { useState, useEffect } from 'react' \n\ninterface TimerProps {\n    callback?: () => void,\n    seconds?: number\n}\n\nexport const Timer = (props: TimerProps) => {\n    const [timeLeft, setTimeLeft] = useState(props.seconds ?? 120);\n\n    useEffect(() => {\n        if (timeLeft <= 0) {\n            if (props.callback)\n                props.callback();\n            return;\n        }\n\n        const timeout = setTimeout(\n            () => setTimeLeft((prev) => prev - 1)\n        , 1000);\n        \n        return () => clearTimeout(timeout); \n    }, [timeLeft]);\n\n    return (\n        <div>\n            <span> {Math.floor(timeLeft / 60).toString().padStart(2, \"0\")} </span>\n            :\n            <span> {Math.floor(timeLeft % 60).toString().padStart(2, \"0\")} </span>\n        </div>\n    );\n}","const API_URL = 'https://toloka.suricatvision.com:8443/predictions/biometric'\n\ninterface SubmitImageParameters {\n    imageURL: string,\n    id: string,\n    assignmentId: string,\n    cameraSelected: MediaDeviceInfo,\n    cameraList: MediaDeviceInfo[],\n    passedTime: number | null,\n}\n\nexport const submitImage = async (params: SubmitImageParameters) => {\n    const imageEncoded = params.imageURL.split(',')[1];\n    return fetch(API_URL, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(JSON.stringify({\n            image: imageEncoded,\n            id: params.id,\n            assignmentId: params.assignmentId,\n            camera_name: {\n                deviceId: params.cameraSelected?.deviceId,\n                label: params.cameraSelected?.label\n            },\n            camera_list: params.cameraList?.map(x => {\n                return {\n                    deviceId: x.deviceId, \n                    label: x.label\n                }\n            }),\n            passedTime: params.passedTime || null,\n        }))\n    })\n        .then(res => res.json())\n        .catch((err) => {\n            // console.log(err);\n            return null;\n        });\n}\n","import React, { useState, useEffect } from 'react';\nimport { useLocation, useParams } from 'react-router-dom';\nimport { Webcam, Timer } from '../components';\nimport { submitImage } from '../faceAPI';\nimport { useTranslation } from 'react-i18next';\n\nexport function WebcamPage() {\n    const location = useLocation();\n    const seed = new URLSearchParams(location.search).get('key');\n    const language = new URLSearchParams(location.search).get('language');\n    const faceID = new URLSearchParams(location.search).get('faceid');\n    const [ expired, setExpired ] = useState(false);\n    const [ expiredT, setExpiredT ] = useState(false);\n    const [ passed, setPassed ] = useState(false);\n    const [ uploaded, setUploaded ] = useState(false);\n    const { t, i18n } = useTranslation('common');\n\n    useEffect(() => {\n        i18n.changeLanguage(language ?? 'en');\n    }, []);\n\n    if (!faceID || !seed)\n        return <div></div>;\n\n    const res = btoa(atob(seed) + '|>*<|' + 'aaaaa');\n\n    \n    console.log(expired, expiredT, passed);\n\n    if (expired && !expiredT && !passed)\n        return <div>{t('webcam.view.timer.expired')}</div>;\n\n    return (\n        <div> \n            <Webcam \n                assignmentId={atob(seed)} \n                callback={() => setPassed(true)} \n                expiredCallback={() => setExpired(true)} \n                faceID={faceID} \n                submitImage={submitImage}\n                uploadCallback={() => setUploaded(true)}\n                passed={expiredT}\n            >\n                <div>\n                    <b>{t('webcam.view.timer.title')}</b> \n                    <br />\n                    <Timer seconds={240} callback={() => setExpiredT(true)} />\n                    <br />\n                    {(passed || expiredT) && uploaded ?\n                        <div>\n                            {t('webcam.view.success.text', {key: res})} \n                            <button className=\"pl-2 underline text-gray-600\" onClick={async () => {\n                                await navigator.clipboard.writeText(res);\n                            }}> \n                                {t('webcam.view.success.copy_button')} \n                            </button>\n                        </div>\n                    : null}\n                </div>\n            </Webcam>\n        </div>\n    );\n}","import React from 'react';\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom'\nimport { WebcamPage } from './views';\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route path='/'> <WebcamPage /> </Route>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport i18next from 'i18next';\nimport { I18nextProvider } from 'react-i18next';\nimport common_en from './translations/en/common.json';\nimport common_ru from './translations/ru/common.json';\n\ni18next.init({\n  interpolation: { escapeValue: false }, \n  lng: 'en',\n  resources: {\n    en: {\n      common: common_en\n    },\n    ru: {\n      common: common_ru\n    }\n  }\n});\n\nReactDOM.render(\n  <React.StrictMode>\n    <I18nextProvider i18n={i18next}>\n      <App />\n    </I18nextProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}